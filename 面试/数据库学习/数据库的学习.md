<<<<<<< HEAD

# 	数据库---子查询的学习

## 1.不相关子查询

**定义**：子查询可以独立运行，先运行子查询，再运行外查询

**特点**：一条语句中包含多个SELECT

**分类**：根据子查询的结果行数，分为不相关子查询分为单行子查询、多行子查询	

​	单行子查询：可以直接用于比较，常用 > < =

​	多行子查询：不可以直接用于比较，关键词为 in any all

​		in：条件在子查询的集合中的任意一个即可，in就相当于=any，in不能跟比较符同时使用

​		any：可以理解为对于子查询返回的列中的任意数值，如果比较结果为True，则返回True，any相对于in更灵活，any可以跟比较符同时使用

​		all：可以理解为对于子查询返回的列中的所有数值，如果比较结果为True，则返回True，all可以跟比较符同时使用。

**好处**：简单理解

**坏处**：但写起来会比较复杂

**例子**：

​	查询所有比“CLARK”工资高的员工的信息

select * from emp where sal > (select sal from emp where ename = "CLARK")

## 2.相关子查询

**定义**：子查询不可以独立运行，需依赖外查询。并且先运行外查询，再运行子查询

**好处**：简单，功能强大。一些使用不相关子查询不能实现或者实现繁琐的子查询时，可以使用相关子查询实现。

**坏处**：理解稍微困难

**例子**：

​	查询本部门最高工资的员工

select * from emp e where = sal(select max(sal) form emp deptno = e.deptno)

--------------



# 数据库零基础学习

## 1. 表的理解

#### 1.什么是表？

**表：Table，是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强**

​	表包含行和列：

​		行：被称为数据/记录（data）

​		列：被称为字段（column）

#### 2.每一个字段应该包括哪些属性？

​	**字段包含字段名、数据类型、相关的约束：**

​		字段名：下列例子中的学号、姓名、年龄为字段名

​		数据类型：数据库类型则为括号中的int、Varchar

​			整形：int

​			字符串：Varchar（可变字符串）

​		相关的约束：暂时不学

例子：

​	学号（int）		姓名（Varchar）		年龄（int）

-------------------------------------------------------------------------------

​	110				张三				20

​	120				李四				21

## 2. SQL语句的分类

**DQL**（数据查询语言）：查询语句，凡是select语句都是DQL

**DML**（数据操作语言）：Insert、delete、update，对表当中的数据进行增删改

**DDL**（数据定义语言）：Create、drop、alter，对表结构的增删改

**TCL** （事务控制语言）：commit提交事务，rollback回滚事务。TCL的T是Transaction

**DCL**（数据控制语言）：grant授权、revoke撤销权限等。

​		**例子**：root超管--->创建其他用户（授权或者撤销授权）时使用DCL

### 3. 导入数据&MYSQL的常用命令

#### 1.登录MYSQL数据库管理系统

​	doc命令窗口：mysql -uroot -p+密码

#### 2.查看有哪些数据库

​	show databases；（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 3.创建一个数据库

​	create database bjpowernode;（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 4.使用bjpowernode数据库

​	use bjpowernode；（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 5.查看当前使用的数据库中有哪些表

​	show tables；（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 6.初始化数据

​	source D:\D:\杂七杂八\mysql_scripts\mysql-5.7.20-winx64\bjpowernode.sql

#### 7.删除数据库

​	drop database bjpowernode;（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 8.查询当前使用的数据库

​	select database();

#### 9.查看数据库版本

​	select version();

#### 10.终止一条MYSQL语句

​	\c

#### 11.退出MYSQL

​	exit

#### 12.查看创建表的语句

​	show create table emp;

### 4. SQL脚本的理解

#### 1.什么是SQL脚本

**当一个文件的拓展名是.sql，并且改文件中编写了大量的sql语句，我们称这样的文件为sql脚本。**

> **注意：直接使用source命令可以执行sql脚本。**

> **sql脚本中的数据量太大的时候，无法打开，请使用source命令完成初始化**

### 5. 查看表结构

#### bjpowernode内的所有表

​	mysql> show tables;
​	+-----------------------+
​	| Tables_in_bjpowernode |
​	+-----------------------+
​	| dept                  |		（部门表）
​	| emp                  |	 （员工表）
​	| salgrade           |	  （工资等级表）
​	+-----------------------+

**查看dept表结构：**

mysql> desc dept;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| DEPTNO | int(2)      | NO   | PRI | NULL    |       |	（部门编号）
| DNAME  | varchar(14) | YES  |     | NULL    |       |	  （部门名称）
| LOC    | varchar(13) | YES  |     | NULL    |       |		（部门位置）
+--------+-------------+------+-----+---------+-------+	

**查看emp表结构：**

mysql> desc emp;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| EMPNO    | int(4)      | NO   | PRI | NULL    |       |	（员工编号）
| ENAME    | varchar(10) | YES  |     | NULL    |       |	（员工姓名）
| JOB      | varchar(9)  | YES  |     | NULL    |       |		（工作岗位）
| MGR      | int(4)      | YES  |     | NULL    |       |		（上级领导编号）
| HIREDATE | date        | YES  |     | NULL    |       |	（入职日期）
| SAL      | double(7,2) | YES  |     | NULL    |       |		（月薪）
| COMM     | double(7,2) | YES  |     | NULL    |       |	（补助/津贴）
| DEPTNO   | int(2)      | YES  |     | NULL    |       |		（部门编号）
+----------+-------------+------+-----+---------+-------+

**查看salgrade表结构：**

mysql> desc salgrade;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| GRADE | int(11) | YES  |     | NULL    |       |		（等级）
| LOSAL | int(11) | YES  |     | NULL    |       |  	（最低薪资）
| HISAL | int(11) | YES  |     | NULL    |       |		（最高薪资）
+-------+---------+------+-----+---------+-------+



### 6.简单的查询SQL语句

#### 1.语法格式

​	select 字段名1，字段名2，字段名3，..... from 表名；

#### 2.提示

​	任何一条sql语句都以“；”结尾。

​	sql语句不区分大小写。

​	字段可以参与数学运算

​	实际使用中最好不要用*，效率较低

​	字符串需要使用单引号括起来

​	null不是一个值，不能用等号衡量。它是空。必须使用is null 或者is not null。

#### 3.条件查询的使用

​	运算符：>、<、=、>=、<=、!=

​	between...and...			两个值之间，字符串为左闭右开

​	is null 和 is not null		为空和不为空，不能使用=号

​	and		并且		and的优先级比or高

​	or		或者

​	in		等同于or		in的条件值不是区间，而是具体的值

​	not		主要使用在is或者in 用来取非

​	like		模糊查询，用到%和_ %代表任意多个字符，_代表任意一个字符，如果查找的数据中有下划线的，那么需要使用\反斜杠进行转义即可

**给查询结果的字段重命名**

​	select ename,sal * 12 as yearsal from emp;

​		说明：使用as+重新定义的名字即可

**重命名使用中文**

​	select ename,sal * 12 as ’年薪‘ form emp;

​		说明：用单引号或者双引号引起来即可，但其他数据库只能用单引号，所以建议习惯使用单引号。

**重命名时as可以省略，用空格隔开**

​	select ename,sal * 12 yearsal from emp;

### 7.条件查询

#### 1.语法格式

​	select 字段 from where...执行顺序先from后where再select

#### 2.例子：

​	**1.找出工资在1100至3000之间的员工，包括1100和3000**

​	select ename,sal from emp where sal >= 1100 and sal <= 3000;

或	select ename,sal from emp where sal between 1100 and 3000;

​		这里的 between...and...是闭区间 【使用时注意左小右大】

		>between...and...也可以用在字符串方面，左闭右开A~C则不包含C

> **select ename from emp where ename between 'A' and 'C'**

​	**2.查出那些人津贴为null**

​	select ename,sal,comm from emp where comm is null

​	**3.查出那些人津贴不为null**

​	select ename,sal,comm from emp where comm is not null

​	**4.找出那些人没有津贴**

​	select ename,sal,comm from emp where comm is not null or comm = 0

​	**5.找出工作岗位是MANAGER和SALESMAN的员工**

​	select ename,jon from emp where job = 'MANAGER' or job = 'SALESMAN'

		>注意：这里的和不代表使用and，and是并且的意思，or才是或者

​	**6.and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工**

​	错误写法：select ename,sal,deptno from emp where sal > 1000 and deptno = 20 or deptno = 30

		>错误的原因是因为and的优先级比or高，就导致大于1000的条件仅满足20部门，而不满足30部门。

​	正确写法：select ename,sal,deptno from emp where sal > 1000 and （deptno = 20 or deptno = 30）

> **使用括号括起来来降低and的优先级**
>
> **注意：当运算符的优先级不确定时可以添加小括号。来保证条件满足**

​	**7.找出工作岗位是MANAGER和SALESMAN的员工**

​	第一种写法：select ename,job from emp where job = 'MANAGER' or job = 'SALESMAN';

​	第二种写法：select ename,job from emp where job in ('MANAGER','SALESMAN');

​	**8.找出名字当中含有O的**

​	select ename from emp where ename like '%O%';

​	**9.找出名字中第二个字符为A的**

​	select ename from emp where ename like '_A%'; 

​	**10.找出名字包含_的**

​	select ename from emp where ename like '%\_%';

	注意：如果模糊搜索的名称中带有下划线的，那么需要使用\转义即可

​	11.找出名字最后一个字母是T的

​	select ename from emp where ename like '%T';

### 8.数据排序（升序、降序）

#### **1.语法格式**

​	order by 或 order by...asc 或 order...desc

​	select ename,sal from emp order by sal			默认为升序

​	select ename,sal from emp order by sal asc		指定为升序

​	select ename,sal from emp order by sal	desc	指定为降序	

#### 2.例子：

​	**1.按照工资升序，找出员工名和薪资**

​	select ename,sal from emp order by sal asc

​	**2.按照工资的降序排列，当工资相同时再按照名字的升序排列**

​	select ename,sal form emp order by sal desc , ename asc;

> **注意：order by 有先后顺序，越靠前的字段越能起到主导作用，只有当前面的字段无法完成排序时，才会启用后面的字段。多个条件用逗号分隔开。**
>
> **注意2：虽然order by 可以指定字段排序，但不建议使用，因为字段顺序一改变会导致这条sql语句失效。**

​	**3.找出工作岗位为SALESMAN的员工，并且要求薪资的降序排列**

​	select job,sal,ename from emp where job = 'SALESMAN' order by sal desc;

> 执行顺序：先执行form后执行where再执行select最后再查排序输出

### 9.分组函数

#### 1.语法格式（多行处理函数）

​	count	计数

​	sum	求和

​	avg		平均值

​	max	最大值

​	min		最小值

> **注意：所有的分组函数都是对“某一组”数据进行操作的**
>
> **特点：分组函数会自动忽略null**

#### 2.例子：

​	**1.工资总和**

​	select sum(sal) from emp;

​	**2.找出最高工资**

​	select max(sal) from emp;

​	**3.找出最低工资**

​	select min(sal) from emp;

​	**4.找出平均工资**

​	select avg(sal) from emp;

​	**5.找出总人数**

​	select count(ename) from emp;

​	select count(*) from emp;

> **分组函数还有另外一个名字：多行处理函数。意思是输入多行输出一行**
>
> **除了多行处理函数，还有单行处理函数：输入一行处理一行**

​	**6.计算每个员工的年薪**

​	select ename,(sal+ifnull(comm,0)) * 12 as yearsal from emp;

> **重点：如果值中有null参与运算了，那么结果一定为null，所有数据库都是这样。**
>
> **可以使用ifnull空处理函数**
>
> **使用方法：ifnull（可能为null的字段，要当做什么数据处理）**
>
> **ifnull（可能为null的字段,0）意思是这个字段里面可能为null的值都当成0来处理**

​	**7.ifnull举例使用**

​	select ifnull(comm,0) as comm from emp;

> **字段名也会跟着变成ifnull格式，所以最好给他起个别名**

​	**8.找出工资高于平均工资的员工**

​	SELECT ename,sal FROM emp WHERE sal >(SELECT AVG(sal) FROM emp);

> **count（*）不是统计某个字段中数据的个数，而是统计总记录条数（和某个字段无关）**
>
> **count（comm）表示统计comm字段中不为NULL的数据总数量**

### 10.group by 和having

#### 1.语法格式

select 字段 from 表 group by 需要分组的字段 having 分组函数

 	group by：按照某个字段或者某些字段进行分组

​	having：对分组后的数据进行再次过滤

> **having是group by的搭档，不能单独使用**

**SQL语句的执行顺序：**

​	select				5 -----查询出来

​		..				字段名

​	from				1 -----查询什么表

​		..				表名

​	where				2 -----第一层过滤

​		..				条件，使用条件查询

​	group by			3 -----把字段进行分组

​		..				字段名

​	having				4 -----第二层过滤

​		..				条件，使用分组函数

​	order by				6 -----将查询完筛选完的数据进行排序

​		..				字段名、升序/降序

> **SQL语句当中有一个规则：分组函数不能直接使用在where子句后面？**
>
> **原因：因为where执行在group by之前，还未进行分组所以无法使用分组函数。**

> **注意：group by一般和分组函数一起使用，这也是为什么会被称为分组函数，并且任何一个分组函数（count sum avg max min）都是在group by语句执行结束之后才会执行。**
>
> **当一条sql语句没有group by的话，整张表的数据会自成一组。**

#### 2.例子：

​	**1.找出每个工作岗位的最高薪资**

​		SELECT job,MAX(sal) FROM emp GROUP BY job;

> SELECT ename，MAX(sal),job from emp group by job;
>
> **MYSQL当中：当一条SQL语句里面有group by时，select后面一定只能跟分组的字段和分组函数，而不能带其他字段，否则数据是对应不上的**
>
> **Oracle当中：会在执行后直接报错，oracle的语法规则比mysql语法严谨**

​	**2.每个工作岗位的平均薪资**

​	select job,avg(sal) from emp group by job;

​	**3.找出每个部门不同岗位的最高薪资**

​	select deptno,job,max(sal) from emp group by deptno,job;

> **联合分组在group by 后面加字段名即可，使用逗号隔开**

​	**4.找出每个部门的最高薪资，要求显示薪资大于2900的数据**

​	select deptno,max(sal) from emp where sal > 2900 group by deptno;

> **上面这种先使用where过滤后在分组的效率较高，建议使用**
>
> **还有一种解法：select deptno,max(sal) from emp group by having max(sal) > 2900;**
>
> **这种解法是先进行分组再过滤条件，这种效率较低，能不使用尽量不使用**

​	5.找出每个部门的平均薪资，要求显示薪资大于2000的数据

select deptno,avg(sal) from emp where sal > 2000 group by deptno;

> **上面这种解法是错误的，因为要得出每个部门的平均薪资是需要分组后进行分组函数的计算后才能得出的结果，如果使用where的话就会在分组计算前把2000给筛选掉，所以这里要使用having，分组后再进行过滤条件。而且where中不能使用分组函数，所以直接计算平均再筛会报错**

正确解法：select deptno,avg(sal) from emp group by deptno having avg(sal) > 2000;

## 11.DQL语句-总结

#### 1.完整语句 ----单表查询

> ​	*select*
>
> ​		..
>
> ​	from
>
> ​		..
>
> ​	where
>
> ​		..
>
> ​	group by
>
> ​		..
>
> ​	having
>
> ​		..
>
> ​	order by
>
> ​		*..*

### 12.distinct

#### 1.语法格式：

**distinct  去重，应用在select当中的字段**

select distinct 字段名 from 表名;

#### 2.例子

​	**1.关于查询结果集的去重**

​	select distinct job from emp;

> select ename,distinct job from emp;
>
> **以上SQL语句是错误的，distinct必须要在所有字段的最前面。**
>
> select distinct job,deptno from emp;
>
> **distinct会对select后的所有字段联合进行去重，而不是某一字段**

​	**2.统计岗位的数量**

​	select count(distinct deptno) from emp;

> **使用括号把distinct和岗位去重，之后再使用count计数。**

## 13.连接查询

**定义**：实际开发中，大部分的情况下都是不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。一般一个业务都会对应多张表。

**分类**：

**1.根据语法出现的年代来划分：**

​	SQL92：较老的语法（一些老的DBA可能还在使用这种语法，DBA：Database Admininstrator，数据库管理员）

​	SQL99：较新的语法

**2.根据表的连接方法来划分：**

​	**内连接：**

​		等值连接

​		非等值连接 between..and..（区间）

​		自连接

​	**外连接**

​		左外连接（左连接）

​		右外连接（右连接）

​	**全连接（这个不讲，很少用）**

**3.在表的连接查询方面有一种现象被称为：笛卡尔积现象（笛卡尔乘积现象）**

**现象**：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。

**不同表的连接查询原理**：两个表之间的连接查询是指A表的字段内一个数据拿来跟B表的字段内所有数据匹配，即1匹配多

​	**例子：找出每一个员工的部门名称，要求显示员工名和部门名**

​	select ename,dname from emp,dept;

​		14*4 = 56 rows in set (2.04 sec)，一共查出56条数据。

**如何避免笛卡尔积现象？或者说避免了笛卡尔积现象就能减少匹配次数了吗？**

​	**并不会，次数还是56次，只是显示的记录是有效记录，但匹配次数不变。**

​	select e.ename,d.dname from emp e,dept d where e.deptno = d.deptno; 

> 这样查询出来的数据就是为14条且部门一一对应，但匹配次数还是56次。

​	**关于表的别名：**

​		select e.ename d.dname from emp e,dept d;

​		1.执行效率高

​		2.可读性好

### 内连接-等值连接

**特点**：条件为等量关系。指的是A表与B表的连接条件为等量关系。他们之间是对等“=”的。

**语法顺序**

> ​	...
>
> ​	A
>
> ​	join
>
> ​	B
>
> ​	on
>
> ​	连接条件
>
> ​	where
>
> ​	...

​	例子：查询每个员工的部门名称，要求显示员工名和部门名

​	**SQL92写法：**

> select 
>
> ​	e.ename,d.dname 
>
> from 
>
> ​	emp e,dept d 
>
> where 
>
> ​	e.deptno = d.deptno;

​	**SQL99写法：**

> select 
>
> ​	e.ename,d.dname 
>
> from 
>
> ​	emp e 
>
> inner join	 (inner可以省略,带着inner的目的是可读性好一些,知道是使用内连接。)
>
>  	dept d
>
>  on 
>
> ​	e.deptno = d.deptno;

> **SQL99语法结构更清晰一些，表的连接条件和where条件分离了。**
>
> **92语句是使用where条件来连接表，但这样的话表连接后的数据筛选就没办法使用where条件了。所以99语法在这方面进行了优化。加入了join和on之后把where条件分离出来。**

### 内连接-非等值连接

**特点：连接条件中的关系是非等量关系。**

​	**例子：找出每个员工的工资等级，要求显示员工名、工资、工资等级**

​	SELECT e.ename,e.sal,s.grade FROM emp e JOIN salgrade s ON e.SAL BETWEEN s.LOSAL AND s.HISAL;

### 内连接-自连接

**特点：一张表看做两张表，自己连自己。**

​	**例子：找出每个员工的上级领导，要求显示员工名和对应的领导名**

​	select a.ename,b.ename from emp a join emp b on a.mgr = b.empno;

### 外连接

**内连接和外连接的区别：**

​	**内连接：**假设A表和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来。这就是内连接。AB之间没有主副之分，平等关系。

​	**外连接：**假设A表和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，另外一张是副表，主要查询主表中的数据，捎带着查询副表，如果副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。

> **左外连接：表示左边的表是主表**

> **右外连接：表示右边的表是主表**

	>**左连接有右连接的写法，右连接也有左连接的写法。**

​	**例子：**找出每个员工的上级领导

​	左外连接：

select a.ename,b.ename from emp a **left** join emp b on a.mgr = b.empno;	

​	右外连接：

select a.ename,b.ename from emp b **right** join emp a on a.mgr = b.empno;

> **左右连接的差别：左连接用left，右连接用right。**
>
> **左连接左表当主表，右表当副表**
>
> **右连接右表当主表，左表当副表**
>
> **外连接使用的比内连接的多。**
>
> 外连接最重要的特点就是主表的数据无条件的查询出来，不能因为null就连带着主表的数据一并不展示。

#### 三张表进行连接查询

​	例子：找出每一个员工的部门名称、工资等级、上级领导

> SELECT e.ename '员工',a.ename '领导',d.dname,s.grade 
> FROM emp e 
> JOIN dept d
> ON e.DEPTNO = d.DEPTNO
> JOIN salgrade s 
> ON e.SAL BETWEEN s.LOSAL AND s.HISAL
> LEFT JOIN emp a
> ON e.MGR = a.EMPNO;



### 14.子查询

**定义：select语句当中嵌套select语句，被嵌套的select语句就是子查询。**

**子查询出现在哪里：可以出现在select、from和where**

> ​	select
>
> ​	.. (select)
>
> ​	from
>
> ​	.. (select)
>
> ​	where
>
> ​	.. (select)

**1.where子句中使用子查询**

**例子：找出高于平均薪资的员工**

​	select * from emp where sal > (select avg(sal) from emp);

**2.from后面嵌套子查询**

​	**例子1：找出每个部门平均薪水的薪资等级**

> SELECT
> d.*,s.grade
> FROM
> (SELECT deptno,AVG(sal) avgsal FROM emp GROUP BY deptno) d
> JOIN
> salgrade s
> ON
> d.avgsal BETWEEN s.LOSAL AND s.HISAL;
>
> 这种from后面嵌套子查询会非常常用。
>
> 嵌套的子查询会把他当做一个临时表使用

**例子2：找出每个部门平均的薪水等级（跟以上例子无关）**

> SELECT 
> e.DEPTNO,AVG(s.grade) 
> FROM emp e 
> JOIN salgrade s 
> ON e.SAL 
> BETWEEN s.LOSAL 
> AND s.HISAL 
> GROUP BY e.DEPTNO;

**3.select后面嵌套子查询**

​	**例子：找出每个员工所在的部门名称，要求显示员工和部门名**

> SELECT e.ename,
> (SELECT d.dname FROM dept d WHERE d.deptno = e.deptno) ename 
> FROM emp e;

### 15.union

**定义：可以将查询结果集相加，就是把查询语句的结果结合在一起。**

​	**例子：找出工作岗位是SALESMAN和MANAGER的员工**

​	**第一种解法：**

> select ename,job from emp where job = 'SALESMAN' or job = 'MANAGER'

​	**第二种解法：**

> select ename,job from emp where job in ('SALESMAN','MANAGER')

​	**第三种解法：**

> ​	select ename from emp where job = 'SALESMAN'
>
> ​	union
>
> ​	select ename from emp where job = 'MANAGER'

### 16.limit(分页查询；重点中的重点！)

**定义：limit是MYSQL特有的，其他数据库没有，不通用。**

**作用：limit是取结果集中的部分数据。**

> Oracle中有一个相同的机制，叫做rownum
>
> **limit是SQL语句中最后执行的一个环节**

语法格式：limit startIndex，length

​	startIndex表示起始位置

​	length表示取几个

​	**例子：取出工资前5名的员工（降序取前5个）**

> ​	SELECT
> ​	ename,sal
> ​	FROM
> ​	emp
> ​	ORDER BY
> ​	sal DESC
> ​	LIMIT 0,5;

​	**例子：取出工资第4名到第9名的员工**

> ​	SELECT
> ​	ename,sal
> ​	FROM
> ​	emp
> ​	ORDER BY
> ​	sal DESC
> ​	LIMIT 3,6;

#### 17.TimeStampDiff（时间间隔查询）

**语法格式：**

​	TimeStampDiff（间隔类型，要查询的字段名，now（））

**间隔类型：**

​	SECOND		秒

​	MINUTE		分钟

​	HOUR		小时

​	DAY			天

​	WEEK		星期

​	MONTH		月

​	QUARTER	季度

​	YEAR		年

## MYSQL-34道练习题

#### 1.取得每个部门最高薪水的人员名称

第一步：查询每个部门的最高薪资

第二步：把第一步当临时表，把ename与临时表进行条件匹配即可

> SELECT a.ENAME,b.*
> FROM emp a 
> JOIN (SELECT deptno,MAX(sal) maxsal FROM emp GROUP BY deptno) b
> ON
> a.SAL = b.maxsal AND a.DEPTNO = b.deptno;

#### 2.那些人的薪水在部门的平均薪水之上

> SELECT a.ename,a.sal,b.avgsal
> FROM
> emp a
> JOIN
> (SELECT deptno,AVG(sal) AS avgsal FROM emp GROUP BY deptno) b
> ON
> b.deptno = a.deptno AND a.sal > b.avgsal
> ORDER BY  
> sal DESC;

#### 3.取得部门中（所有人）平均的薪水等级

**所有人的平均薪资的等级**

> SELECT
> b.*,s.grade
> FROM
> salgrade s
> LEFT JOIN
> (SELECT ename,AVG(sal) AS avgsal FROM emp GROUP BY ename) b
> ON
> b.avgsal BETWEEN s.losal AND s.hisal;

**部门的平均的薪水等级**

> SELECT 
> e.DEPTNO,AVG(s.grade) 
> FROM emp e 
> JOIN salgrade s 
> ON e.SAL 
> BETWEEN s.LOSAL 
> AND s.HISAL 
> GROUP BY e.DEPTNO;

#### 4.不准用分组函数MAX，取得最高薪水（给出2种解决方案） 

第一种：把工资降序，然后limit展示第一条数据，就是最高工资了。

select ename,sal from emp order by sal desc limit 0,1;

第二种：使用自连接，创建一条sal临时表，salA表小于salB表，由于A表最高工资不会小于B表里的任何工资，所以不会展示出来，这种情况下在使用is not把最高工资拿出来即可。

select distinct a.sal from emp a join emp b on a.sal<b.sal ----子查询

select sal from emp where sal not in (子查询表)



#### 5.取得平均薪水最高的部门的部门编号（至少给2种解决方案）

**第一种：使用limit排序，把工资降序然后limit展示第一条数据即可**

**步骤：先找出各个部门的平均薪水，然后排序再limit**

> SELECT 
> deptno,AVG(sal) avgsal 
> FROM 
> emp 
> GROUP BY 
> deptno 
> ORDER BY 
> avgsal 
> DESC 
> LIMIT 0,1;

**第二种：使用MAX，把部门平均薪水表当成临时表后求最大即可**

**步骤：先找出各个部门的平均薪水，然后当临时表使用MAX分组函数求最大值**

> SELECT 
> t.deptno,MAX(t.avgsal) 
> FROM 
> (SELECT deptno,AVG(sal) avgsal FROM emp GROUP BY deptno) t;



#### 6.取平均薪水最高的部门的部门名称

**解法：使用limit排序，把平均工资得出来后当成临时表，用外连接把临时表跟部门表连接，然后根据临时表的平均部门工资进行倒序，然后limit筛出。**

> SELECT
> d.dname,AVG(sal) avgsal
> FROM
> emp e
> JOIN
> dept d
> ON
> e.deptno = d.deptno
> GROUP BY
> e.deptno
> ORDER BY
> avgsal DESC
> LIMIT
> 0,1;

#### 7.求平均薪水的等级最低的部门的部门名称

**解法：使用limit排序，把平均薪水的等级按照部门分组，然后在根据等级来升序，最后用limit来过滤。**

> SELECT
> e.dname,e.avgsal,s.grade
> FROM
> (SELECT d.dname,a.deptno,AVG(a.sal) avgsal FROM emp a JOIN dept d ON a.deptno = d.deptno GROUP BY deptno) e
> LEFT JOIN
> salgrade s
> ON
> avgsal BETWEEN s.losal AND s.hisal
> GROUP BY
> e.DEPTNO
> ORDER BY
> s.grade ASC
> LIMIT
> 0,1;

#### 8.取的比普通员工（员工代码没有在mgr字段上出现的）的最高薪水还要高的领导人姓名

**解法：先使用去重把领导人都筛出来当临时表，然后用emp表对比这个临时表，把普通员工的最高薪水得出来，然后用emp的薪资对比临时表得出结果**

> SELECT
> ename
> FROM
> emp
> WHERE
> sal > (SELECT
> MAX(sal)
> FROM
> emp
> WHERE
> empno NOT IN (SELECT DISTINCT mgr FROM emp WHERE mgr IS NOT NULL))

#### 9.取得薪水最高的前五名员工

**解法：使用order by把薪资降序排列，后用limit过滤**

> SELECT
> ename,sal
> FROM
> emp
> ORDER BY
> sal DESC
> LIMIT
> 0,5

#### 10.取得薪水最高的第六到第十名员工

**解法：使用order by把薪资降序排列，后用limit过滤**

> SELECT
> ename,sal
> FROM
> emp
> ORDER BY
> sal DESC
> LIMIT
> 5,5

#### 11.取得最后入职的5名员工

**解法：使用order by把入职日期降序排列，后用limit过滤**

> SELECT
> ename,hiredate
> FROM
> emp
> ORDER BY
> hiredate DESC
> LIMIT
> 0,5

#### 12.取得每个薪水等级有多少名员工

**解法：使用分组函数count计数，然后给grade分组即可。**

> SELECT
> s.grade AS '薪资等级',COUNT(s.grade) AS '共计员工数'
> FROM
> emp e
> JOIN
> salgrade s
> ON
> e.sal BETWEEN s.losal AND s.hisal
> GROUP BY
> s.grade

#### 13.有3个表s（学生表），c（课程表），sc（学生选课表）

s（sno，sname）代表（学号，姓名）

c（cno，cname，cteacher）代表（课号，课名，教师）

sc（sno，cno，scgrade）代表（学号，课号，成绩）

问题1：找出没选过“黎明”老师的所有学生姓名

问题2：列出2门以上（含2门）步即可学生姓名及平均成绩

问题3：即学过1号课程又学过2号课程的所有学生的姓名

#### 14.列出所有员工及领导的姓名

**解法：使用左外连接查询，可以把null也展示出来**

SELECT
a.ename,b.ename
FROM
emp a
LEFT JOIN
emp b
ON
a.mgr = b.empno;

#### 15.列出受雇日期早于其直接上级的所有员工的编号、姓名、部门名称

**解法：先用自连接把员工和直接上级筛选出来，然后再外连接dept表，把部门名称取出来，最后用where条件把员工入职日期早于领导入职日期过滤出来**

> SELECT
>
> a.empno,a.ename,d.dname,a.hiredate,b.hiredate
> FROM
> emp a
> LEFT JOIN
> emp b
> ON
> a.mgr = b.empno
> LEFT JOIN
> dept d
> ON
> a.deptno = d.deptno
> WHERE
> a.hiredate < b.hiredate;

#### 16.列出部门名称和这些部门的员工信息，同时列出哪些没有员工的部门

**解法：列出所有的员工信息和部门名称即可**

> SELECT
> a.dname,e.*
> FROM
> dept a
> JOIN
> emp e
> ON
> a.deptno = e.deptno;

#### 17.列出至少有5个员工的所有部门

**解法：group by对deptno分组，然后count计数即可，我使用了外连接是因为我以为需要取得部门名称，实际不需要，下面列出2种写法中第一张是取得部门名称，而第二种没有。**

**第一种：取得员工数量大于等于5的部门名称**

> SELECT
> d.dname
> FROM
> dept d
> JOIN
> emp e
> ON
> d.deptno = e.deptno
> GROUP BY
> e.deptno
> HAVING
> COUNT(e.deptno) >= 5;

#### **第二种：取得员工数量大于等于5的部门编号**

> SELECT
> deptno
> FROM
> emp
> GROUP BY
> deptno
> HAVING
> COUNT(deptno) >= 5;

#### 18.列出薪资比“SMITH”多的所有员工信息 

**解法：子查询得出SMITH的薪资，后再用SAL去比较SMITH的薪资，得出结果**

> SELECT
> *
> FROM
> emp
> WHERE
> sal > (SELECT sal FROM emp WHERE ename = 'SMITH');

#### 19.列出所有办事员（CLERK）的姓名及其部门名称和部门的人数

**解法：**

**1.先找出所有办事员为'CLERK'的姓名、部门名称**

**2.然后找出部门的人数**

**3.把以上两个SQL语句都当成临时表，拼接即可。**

> SELECT
> t1.*,t2.countdeptno
> FROM
> (SELECT e.ename,d.dname,e.deptno FROM emp e JOIN dept d ON e.deptno = d.deptno WHERE job = 'CLERK') t1
> JOIN
> (SELECT deptno,COUNT() countdeptno FROM emp GROUP BY deptno) t2 ON
> t1.deptno = t2.deptno

#### 20.列出最低薪资大于1500的各种工作及从事此工作的全部雇员人数

**解法：用分组函数把job进行分组，然后用having过滤最低薪资为1500以下的，最后使用count计数即可**

> SELECT
> job,COUNT(job)
> FROM
> emp
> GROUP BY
> job
> HAVING
> MIN(sal) > 1500;

#### 21.列出在部门‘SALES’<销售部>工作的员工的姓名，假定不知道销售部的部门编号

**解法：子查询找出部门名为'SALES'的部门编号，再查询该部门下的员工姓名**

> SELECT
> ename
> FROM
> emp
> WHERE
> deptno = (SELECT deptno FROM dept WHERE dname = 'SALES')

#### 22.列出薪资高于公司平均薪资的所有员工，所在部门，上级领导和雇员的工资等级 

**解法：先找出平均薪资，然后通过表链接找到所在部门和上级领导和工资等级，展示所有条件再加上子查询平均薪资即可**

> SELECT
> e.ename,d.dname,a.ename,s.grade
> FROM
> emp e
> JOIN
> dept d
> ON
> e.deptno = d.deptno
> LEFT JOIN
> emp a
> ON
> e.mgr = a.empno
> JOIN
> salgrade s
> ON
> e.sal BETWEEN s.losal AND s.hisal
> WHERE
> e.sal > (SELECT AVG(sal) FROM emp);

#### 23.列出与“SCOTT”从事相同工作的所有员工及部门名称

**解法：先找出“SCOTT”的工作岗位，然后关联dept表找出部门名称**

> SELECT
> e.ename,e.job,d.dname
> FROM
> emp e
> JOIN
> dept d
> ON
> d.deptno = e.deptno
> WHERE
> e.job = (SELECT job FROM emp WHERE ename = 'SCOTT')
> AND
> e.ename != 'SCOTT'

#### 24.列出薪资等于部门30中员工的薪资的其他员工的姓名和薪资

没理解题意，不写。

#### 25.列出薪资高于在部门30工作的所有员工的薪资的员工姓名和薪资、部门名称

解法：先找出部门30的员工中最高薪资，然后在表链接找出部门名称

> SELECT
> e.ename,e.sal,d.dname
> FROM
> emp e
> JOIN
> dept d
> ON
> e.deptno = d.deptno
> WHERE
> e.sal > (SELECT MAX(sal) FROM emp WHERE deptno = 30);

#### 26.列出在每个部门工作的员工数量，平均工资和平均服务期限

解法：外连接emp和dept表，然后根据deptno分组 ，用分组函数求得员工数量、平均工资和平均服务期限。

> SELECT
> d.deptno,COUNT(e.ename),IFNULL(AVG(e.sal),0),IFNULL(AVG(TIMESTAMPDIFF(YEAR,hiredate,NOW())),0) '时间间隔'
> FROM
> emp e
> RIGHT JOIN
> dept d
> ON
> e.deptno = d.deptno
> GROUP BY
> d.deptno;

#### 27.列出所有员工的姓名、部门名称和工资

**解法：外连接emp表和dept表查询即可**

> SELECT
> e.ename,d.dname,e.sal
> FROM
> emp e
> JOIN
> dept d
> ON
> e.deptno = d.deptno

#### 28.列出所有部门的详细信息和人数

**解法：外连接emp和dept表，右连接dept表，展示dept的所有数据，然后用deptno进行分组，最后用count计算人数即可**

> SELECT
> d.*,COUNT(e.deptno) '人数'
> FROM
> emp e
> RIGHT JOIN
> dept d
> ON
> e.deptno = d.deptno
> GROUP BY
> d.deptno

#### 29.列出各种工作的最低工资及从事此工作的雇员

**解法：先找出每个工种的最低工资，然后用外连接emp表和最低工资表t，条件对比即可**

> SELECT 
> t.*,e.ename
> FROM
> emp e
> JOIN
> (SELECT job,MIN(sal) AS minsal FROM emp GROUP BY job) t
> ON
> e.job = t.job AND e.sal = t.minsal;

#### 30.列出各个部门的MANGER（领导）的最低薪资

**解法：先找出job为‘MANAGER’的员工，然后把部门进行分组，最后用分组函数把最低薪资求出即可**

> SELECT
> deptno,ename,MIN(sal),job
> FROM
> emp
> WHERE
> job = 'MANAGER'
> GROUP BY
> deptno

#### 31.列出所有员工的年工资，按年薪从低到高排序

**解法：找出年工资再排序**

> SELECT
> ename,(sal+IFNULL(comm,0))*12 AS salcomm
> FROM
> emp
> ORDER BY
> salcomm ASC;

#### 32.求出员工领导的薪水超过3000的员工名称和领导

**解法：自连接把员工和领导信息找出来，再通过where条件筛选即可**

> SELECT
> a.ename '员工',b.ename '领导'
> FROM
> emp a
> JOIN
> emp b
> ON
> a.mgr = b.empno
> WHERE
> b.sal > 3000;

#### 33.求出部门名称中带S字符的部门员工的工资合计、部门人数

**解法：右外连接emp和dept，然后where条件筛选部门名称为S的，用group by把dept表进行分组，然后用分组函数得出工资合计和统计部门人数**

> SELECT
> d.dname,d.deptno,d.loc,SUM(e.sal),COUNT(e.deptno)
> FROM
> emp e
> RIGHT JOIN
> dept d
> ON
> e.deptno = d.deptno
> WHERE
> d.dname LIKE '%S%'
> GROUP BY
> d.dname,d.deptno,d.loc

#### 34.给任职时间超过30年的员工加薪10%

用的update，暂时不写。

## 员工部门表综合查询60题

> 注：题目&答案均来自https://www.jianshu.com/p/c591f4769057
>
> 

```csharp
（1） 查询20部门的所有员工信息。
解：
SELECT ename,deptno FROM emp WHERE deptno = 20;
```

```csharp
（2） 查询所有工种为CLERK的员工的员工号、员工名和部门号。
解：
SELECT empno,ename,deptno,job FROM emp WHERE job = 'CLERK';
```

```csharp
（3） 查询奖金（COMM）高于工资（SAL）的员工信息。
解：
SELECT * FROM emp WHERE comm > sal;
```

```csharp
（4） 查询奖金高于工资的20%的员工信息。
解：
SELECT * FROM emp WHERE comm > (sal * 0.2);
```

```csharp
（5） 查询10号部门中工种为MANAGER和20部门中工种为CLERK的员工的信息。
解：
SELECT * FROM emp WHERE (deptno = 10 AND job = 'manager') OR (deptno = 20 AND job = 'CLERK') ORDER BY deptno DESC;
```

```csharp
（6）查询所有工种不是MANAGER和CLERK，--且工资大于或等于2000的员工的详细信息。
解：
SELECT * FROM emp WHERE (job != 'manager' OR 'clerk') AND sal >= 2000;
```

```csharp
（7） 查询有奖金的员工的不同工种。
解：
select distinct job from emp where comm is not null
```

```csharp
（8） 查询所有员工工资与奖金的和。
解：
SELECT ename,(sal+IFNULL(comm,0)) FROM emp;
```

```csharp
（9） 查询没有奖金或奖金低于100的员工信息。
解：
SELECT * FROM emp WHERE comm IS NULL OR comm < 100;
```

```csharp
（10） 查询各月倒数第3天(倒数第2天)入职的员工信息。
解：
SELECT * FROM emp WHERE HIREDATE = LAST_DAY(HIREDATE)-2;
```

```csharp
（11） 查询工龄大于或等于25年的员工信息。
解：
SELECT
*
FROM
emp
WHERE
TIMESTAMPDIFF(YEAR,hiredate,NOW()) >= 25;
```

```csharp
（12） 查询员工信息，要求以首字母大写的方式显示所有员工的姓名。
    解：
    
```

```csharp
（13） 查询员工名正好为6个字符的员工的信息。
    解：
    
```

```csharp
（14） 查询员工名字中不包含字母“Ｓ”的员工。
解：
SELECT ename FROM emp WHERE ename NOT LIKE '%Ｓ%'
```

```csharp
（15） 查询员工姓名的第二字母为“M”的员工信息。
解：
SELECT
*
FROM
emp
WHERE
ename LIKE '_M%'
```

```csharp
（16） 查询所有员工姓名的前三个字符。
```

```csharp
（17） 查询所有员工的姓名，如果包含字母“S”，则用“s”替换。
```

```csharp
（18） 查询员工的姓名和入职日期，并按入职日期从先到后进行排序。
解：
SELECT
ename,hiredate
FROM
emp
ORDER BY
hiredate ASC;
```

```csharp
（19） 显示所有员工的姓名、工种、工资和奖金，按工种降序排序，
解：
SELECT
ename,job,sal,comm
FROM
emp
ORDER BY
job DESC;
```

```csharp
（20） 显示所有员工的姓名、入职的年份和月份，
```

```csharp
（21） 查询在2月份入职的所有员工信息。
```

```csharp
（22） 查询所有员工入职以来的工作期限，用“XX年XX月XX日”的形式表示。
```

```csharp
（23.1） 查询至少有一个员工的部门信息。
解：
SELECT
d.*,COUNT(e.ename) AS countename
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
d.deptno
HAVING
countename > 1;
```

```csharp
（23.2） 查询至少有两个员工的部门信息。
解：
SELECT
d.*,COUNT(e.ename) AS countename
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
d.deptno
HAVING
countename > 2;
```

```csharp
（24） 查询工资比SMITH员工工资高的所有员工信息。
解：
SELECT
*
FROM
emp
WHERE
sal > (SELECT sal FROM emp WHERE ename = 'SMITH');
```

```csharp
（25） 查询所有员工的姓名及其直接上级的姓名。
解：
SELECT
a.ename AS '员工姓名',b.ename AS '领导姓名'
FROM
emp a
JOIN
emp b
ON
a.mgr = b.empno;
```

```csharp
（26） 查询入职日期早于其直接上级领导的所有员工信息。
解：
SELECT
a.ename,a.hiredate '员工入职日期',b.hiredate '领导入职日期'
FROM
emp a
JOIN
emp b
ON
a.mgr = b.empno
WHERE
a.hiredate < b.hiredate;
```

```csharp
（27） 查询所有部门及其员工信息，包括那些没有员工的部门。
解：
SELECT
d.dname,e.ename
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno;
```

```csharp
（28） 查询所有员工及其部门信息，包括那些还不属于任何部门的员工。
解：
SELECT
d.dname,e.ename
FROM
emp e
LEFT JOIN
dept d
ON
e.deptno = d.deptno;
```

```csharp
（29） 查询所有工种为CLERK的员工的姓名及其部门名称。
解：
SELECT
e.job,e.ename,d.dname
FROM
emp e
LEFT JOIN
dept d
ON
e.deptno = d.deptno
WHERE
e.job = 'CLERK';
```

```csharp
（30） 查询最低工资大于2500的各种工作。
解：
SELECT
job
FROM
emp
GROUP BY
job
HAVING
MIN(sal) > 2500;
```

```csharp
（31） 查询平均工资低于2000的部门及其员工信息。
解：
SELECT *
FROM dept LEFT OUTER JOIN emp ON dept.deptno=emp.deptno
WHERE dept.deptno IN (
SELECT deptno FROM emp
GROUP BY deptno
HAVING AVG(sal)<2000)
```

```csharp
（32） 查询在SALES部门工作的员工的姓名信息。
解：
SELECT
d.dname,e.ename
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
WHERE
d.dname = 'SALES';
```

```csharp
（33） 查询工资高于公司平均工资的所有员工信息。
解：
SELECT
*
FROM
emp
WHERE
sal > (SELECT AVG(sal) FROM emp);
```

```csharp
（34） 查询出与SMITH员工从事相同工作的所有员工信息。
解：
SELECT
*
FROM
emp
WHERE
job = (SELECT job FROM emp WHERE ename = 'SMITH')
```

```csharp
（35） 列出工资等于30部门中某个员工的工资的所有员工的姓名和工资。
解：
SELECT
ename,sal
FROM
emp
WHERE
sal IN (SELECT sal FROM emp WHERE deptno = 30)
AND
deptno != 30;
```

```csharp
（36） 查询工资高于30部门工作的所有员工的工资的员工姓名和工资。
解：
SELECT
ename,sal
FROM
emp
WHERE
sal > (SELECT MAX(sal) FROM emp WHERE deptno = 30)
AND
deptno != 30;
```

```csharp
（37） 查询每个部门中的员工数量、平均工资和平均工作年限。
解：
SELECT
e.deptno '部门编号',COUNT(e.ename) '部门人数',AVG(e.sal) '平均工资',AVG(TIMESTAMPDIFF(YEAR,e.hiredate,NOW())) AS '平均年限'
FROM
emp e
JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
e.deptno;
```

```csharp
（38） 查询从事同一种工作但不属于同一部门的员工信息。
```

```csharp
（39） 查询各个部门的详细信息以及部门人数、部门平均工资。
解：
SELECT
d.*,COUNT(e.ename),IFNULL((AVG(e.sal)),0)
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
e.deptno;
```

```csharp
（40） 查询各种工作的最低工资。
解：
SELECT
job,MIN(sal)
FROM
emp
GROUP BY
job;
```

```csharp
（41） 查询各个部门中不同工种的最高工资。
解：
SELECT
d.dname,e.job,MAX(e.sal)
FROM
emp e
JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
d.dname,e.job;
```

```csharp
（42） 查询10号部门员工及其领导的信息。
解：
SELECT
a.ename,b.ename
FROM
emp a
LEFT JOIN
emp b
ON
a.mgr = b.empno
WHERE
a.deptno = 10;
```

```csharp
（43） 查询各个部门的人数及平均工资。
解：
SELECT
d.dname,COUNT(e.ename),IFNULL(AVG(e.sal),0) '平均工资'
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
e.deptno;
```

```csharp
（44） 查询工资为某个部门平均工资的员工的信息。
解：
SELECT
*
FROM
emp
WHERE
sal IN (SELECT AVG(sal) FROM emp GROUP BY deptno)
```

```csharp
（45） 查询工资高于本部门平均工资的员工的信息。
解：
SELECT
*
FROM
emp a
JOIN
(SELECT AVG(sal) avgsal,deptno FROM emp GROUP BY deptno) b
WHERE
a.sal >  b.avgsal AND a.deptno = b.deptno;
```

```csharp
（46） 查询工资高于本部门平均工资的员工的信息及其部门的平均工资。
解：
SELECT
a.ename,b.avgsal
FROM
emp a
JOIN
(SELECT AVG(sal) avgsal,deptno FROM emp GROUP BY deptno) b
WHERE
a.sal >  b.avgsal AND a.deptno = b.deptno;
```

```csharp
（47） 查询工资高于20号部门某个员工工资的员工的信息。
解：
SELECT
*
FROM
emp
WHERE
sal > ANY(SELECT sal FROM emp WHERE deptno = 20);
```

```csharp
（48）统计各个工种的员工人数与平均工资。
解：
SELECT
COUNT(ename),AVG(sal)
FROM
emp
GROUP BY
job;
```

```csharp
（49） 统计每个部门中各工种的人数与平均工资。
解：
SELECT
d.dname,e.job,COUNT(e.ename) countename,AVG(e.sal)
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
d.dname,e.job
ORDER BY
countename ASC;
```

```csharp
（50） 查询其他部门中工资、奖金与30号部门某员工工资、奖金都相同的员工的信息。没有查询结果
```

```csharp
（51） 查询部门人数大于5的部门的员工信息。
解：
SELECT
*
FROM
emp
WHERE
deptno = 
(SELECT
deptno
FROM
emp
GROUP BY
deptno
HAVING
COUNT(ename) >5)
```

```csharp
（52） 查询所有员工工资都大于1000的部门的信息。
解：
SELECT
*
FROM
dept
WHERE
deptno IN (SELECT deptno FROM emp GROUP BY deptno HAVING MIN(sal)> 1000)
```

```csharp
（53） 查询所有员工工资都大于1000的部门的信息及其员工信息。
解：
SELECT *
FROM dept d LEFT OUTER JOIN emp e ON d.deptno=e.deptno
WHERE e.deptno IN (
SELECT deptno FROM emp e1
GROUP BY deptno
HAVING MIN(sal)>1000
)
```

```csharp
（54） 查询所有员工工资都在900～3000之间的部门的信息。
```

```csharp
（55） 查询有工资在900～3000之间的员工所在部门的员工信息。
```

```csharp
（56） 查询每个员工的领导所在部门的信息。
```

```csharp
（57） 查询人数最多的部门信息。
```

```csharp
（58） 查询30号部门中工资排序前3名的员工信息。
```

```csharp
（59） 查询所有员工中工资排序在5到10名之间的员工信息。
```

```csharp
（60） 查询指定年份之间入职的员工信息。(1980-1985)
```

=======
# 	数据库---子查询的学习

## 1.不相关子查询

**定义**：子查询可以独立运行，先运行子查询，再运行外查询

**特点**：一条语句中包含多个SELECT

**分类**：根据子查询的结果行数，分为不相关子查询分为单行子查询、多行子查询	

​	单行子查询：可以直接用于比较，常用 > < =

​	多行子查询：不可以直接用于比较，关键词为 in any all

​		in：条件在子查询的集合中的任意一个即可，in就相当于=any，in不能跟比较符同时使用

​		any：可以理解为对于子查询返回的列中的任意数值，如果比较结果为True，则返回True，any相对于in更灵活，any可以跟比较符同时使用

​		all：可以理解为对于子查询返回的列中的所有数值，如果比较结果为True，则返回True，all可以跟比较符同时使用。

**好处**：简单理解

**坏处**：但写起来会比较复杂

**例子**：

​	查询所有比“CLARK”工资高的员工的信息

select * from emp where sal > (select sal from emp where ename = "CLARK")

## 2.相关子查询

**定义**：子查询不可以独立运行，需依赖外查询。并且先运行外查询，再运行子查询

**好处**：简单，功能强大。一些使用不相关子查询不能实现或者实现繁琐的子查询时，可以使用相关子查询实现。

**坏处**：理解稍微困难

**例子**：

​	查询本部门最高工资的员工

select * from emp e where = sal(select max(sal) form emp deptno = e.deptno)

--------------



# 数据库零基础学习

## 1. 表的理解

#### 1.什么是表？

**表：Table，是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强**

​	表包含行和列：

​		行：被称为数据/记录（data）

​		列：被称为字段（column）

#### 2.每一个字段应该包括哪些属性？

​	**字段包含字段名、数据类型、相关的约束：**

​		字段名：下列例子中的学号、姓名、年龄为字段名

​		数据类型：数据库类型则为括号中的int、Varchar

​			整形：int

​			字符串：Varchar（可变字符串）

​		相关的约束：暂时不学

例子：

​	学号（int）		姓名（Varchar）		年龄（int）

-------------------------------------------------------------------------------

​	110				张三				20

​	120				李四				21

## 2. SQL语句的分类

**DQL**（数据查询语言）：查询语句，凡是select语句都是DQL

**DML**（数据操作语言）：Insert、delete、update，对表当中的数据进行增删改

**DDL**（数据定义语言）：Create、drop、alter，对表结构的增删改

**TCL** （事务控制语言）：commit提交事务，rollback回滚事务。TCL的T是Transaction

**DCL**（数据控制语言）：grant授权、revoke撤销权限等。

​		**例子**：root超管--->创建其他用户（授权或者撤销授权）时使用DCL

### 3. 导入数据&MYSQL的常用命令

#### 1.登录MYSQL数据库管理系统

​	doc命令窗口：mysql -uroot -p+密码

#### 2.查看有哪些数据库

​	show databases；（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 3.创建一个数据库

​	create database bjpowernode;（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 4.使用bjpowernode数据库

​	use bjpowernode；（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 5.查看当前使用的数据库中有哪些表

​	show tables；（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 6.初始化数据

​	source D:\D:\杂七杂八\mysql_scripts\mysql-5.7.20-winx64\bjpowernode.sql

#### 7.删除数据库

​	drop database bjpowernode;（这个是mysql命令，不是sql语句，mysql命令-分号必须要带。）

#### 8.查询当前使用的数据库

​	select database();

#### 9.查看数据库版本

​	select version();

#### 10.终止一条MYSQL语句

​	\c

#### 11.退出MYSQL

​	exit

#### 12.查看创建表的语句

​	show create table emp;

### 4. SQL脚本的理解

#### 1.什么是SQL脚本

**当一个文件的拓展名是.sql，并且改文件中编写了大量的sql语句，我们称这样的文件为sql脚本。**

> **注意：直接使用source命令可以执行sql脚本。**

> **sql脚本中的数据量太大的时候，无法打开，请使用source命令完成初始化**

### 5. 查看表结构

#### bjpowernode内的所有表

​	mysql> show tables;
​	+-----------------------+
​	| Tables_in_bjpowernode |
​	+-----------------------+
​	| dept                  |		（部门表）
​	| emp                  |	 （员工表）
​	| salgrade           |	  （工资等级表）
​	+-----------------------+

**查看dept表结构：**

mysql> desc dept;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| DEPTNO | int(2)      | NO   | PRI | NULL    |       |	（部门编号）
| DNAME  | varchar(14) | YES  |     | NULL    |       |	  （部门名称）
| LOC    | varchar(13) | YES  |     | NULL    |       |		（部门位置）
+--------+-------------+------+-----+---------+-------+	

**查看emp表结构：**

mysql> desc emp;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| EMPNO    | int(4)      | NO   | PRI | NULL    |       |	（员工编号）
| ENAME    | varchar(10) | YES  |     | NULL    |       |	（员工姓名）
| JOB      | varchar(9)  | YES  |     | NULL    |       |		（工作岗位）
| MGR      | int(4)      | YES  |     | NULL    |       |		（上级领导编号）
| HIREDATE | date        | YES  |     | NULL    |       |	（入职日期）
| SAL      | double(7,2) | YES  |     | NULL    |       |		（月薪）
| COMM     | double(7,2) | YES  |     | NULL    |       |	（补助/津贴）
| DEPTNO   | int(2)      | YES  |     | NULL    |       |		（部门编号）
+----------+-------------+------+-----+---------+-------+

**查看salgrade表结构：**

mysql> desc salgrade;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| GRADE | int(11) | YES  |     | NULL    |       |		（等级）
| LOSAL | int(11) | YES  |     | NULL    |       |  	（最低薪资）
| HISAL | int(11) | YES  |     | NULL    |       |		（最高薪资）
+-------+---------+------+-----+---------+-------+



### 6.简单的查询SQL语句

#### 1.语法格式

​	select 字段名1，字段名2，字段名3，..... from 表名；

#### 2.提示

​	任何一条sql语句都以“；”结尾。

​	sql语句不区分大小写。

​	字段可以参与数学运算

​	实际使用中最好不要用*，效率较低

​	字符串需要使用单引号括起来

​	null不是一个值，不能用等号衡量。它是空。必须使用is null 或者is not null。

#### 3.条件查询的使用

​	运算符：>、<、=、>=、<=、!=

​	between...and...			两个值之间，字符串为左闭右开

​	is null 和 is not null		为空和不为空，不能使用=号

​	and		并且		and的优先级比or高

​	or		或者

​	in		等同于or		in的条件值不是区间，而是具体的值

​	not		主要使用在is或者in 用来取非

​	like		模糊查询，用到%和_ %代表任意多个字符，_代表任意一个字符，如果查找的数据中有下划线的，那么需要使用\反斜杠进行转义即可

**给查询结果的字段重命名**

​	select ename,sal * 12 as yearsal from emp;

​		说明：使用as+重新定义的名字即可

**重命名使用中文**

​	select ename,sal * 12 as ’年薪‘ form emp;

​		说明：用单引号或者双引号引起来即可，但其他数据库只能用单引号，所以建议习惯使用单引号。

**重命名时as可以省略，用空格隔开**

​	select ename,sal * 12 yearsal from emp;

### 7.条件查询

#### 1.语法格式

​	select 字段 from where...执行顺序先from后where再select

#### 2.例子：

​	**1.找出工资在1100至3000之间的员工，包括1100和3000**

​	select ename,sal from emp where sal >= 1100 and sal <= 3000;

或	select ename,sal from emp where sal between 1100 and 3000;

​		这里的 between...and...是闭区间 【使用时注意左小右大】

		>between...and...也可以用在字符串方面，左闭右开A~C则不包含C

> **select ename from emp where ename between 'A' and 'C'**

​	**2.查出那些人津贴为null**

​	select ename,sal,comm from emp where comm is null

​	**3.查出那些人津贴不为null**

​	select ename,sal,comm from emp where comm is not null

​	**4.找出那些人没有津贴**

​	select ename,sal,comm from emp where comm is not null or comm = 0

​	**5.找出工作岗位是MANAGER和SALESMAN的员工**

​	select ename,jon from emp where job = 'MANAGER' or job = 'SALESMAN'

		>注意：这里的和不代表使用and，and是并且的意思，or才是或者

​	**6.and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工**

​	错误写法：select ename,sal,deptno from emp where sal > 1000 and deptno = 20 or deptno = 30

		>错误的原因是因为and的优先级比or高，就导致大于1000的条件仅满足20部门，而不满足30部门。

​	正确写法：select ename,sal,deptno from emp where sal > 1000 and （deptno = 20 or deptno = 30）

> **使用括号括起来来降低and的优先级**
>
> **注意：当运算符的优先级不确定时可以添加小括号。来保证条件满足**

​	**7.找出工作岗位是MANAGER和SALESMAN的员工**

​	第一种写法：select ename,job from emp where job = 'MANAGER' or job = 'SALESMAN';

​	第二种写法：select ename,job from emp where job in ('MANAGER','SALESMAN');

​	**8.找出名字当中含有O的**

​	select ename from emp where ename like '%O%';

​	**9.找出名字中第二个字符为A的**

​	select ename from emp where ename like '_A%'; 

​	**10.找出名字包含_的**

​	select ename from emp where ename like '%\_%';

	注意：如果模糊搜索的名称中带有下划线的，那么需要使用\转义即可

​	11.找出名字最后一个字母是T的

​	select ename from emp where ename like '%T';

### 8.数据排序（升序、降序）

#### **1.语法格式**

​	order by 或 order by...asc 或 order...desc

​	select ename,sal from emp order by sal			默认为升序

​	select ename,sal from emp order by sal asc		指定为升序

​	select ename,sal from emp order by sal	desc	指定为降序	

#### 2.例子：

​	**1.按照工资升序，找出员工名和薪资**

​	select ename,sal from emp order by sal asc

​	**2.按照工资的降序排列，当工资相同时再按照名字的升序排列**

​	select ename,sal form emp order by sal desc , ename asc;

> **注意：order by 有先后顺序，越靠前的字段越能起到主导作用，只有当前面的字段无法完成排序时，才会启用后面的字段。多个条件用逗号分隔开。**
>
> **注意2：虽然order by 可以指定字段排序，但不建议使用，因为字段顺序一改变会导致这条sql语句失效。**

​	**3.找出工作岗位为SALESMAN的员工，并且要求薪资的降序排列**

​	select job,sal,ename from emp where job = 'SALESMAN' order by sal desc;

> 执行顺序：先执行form后执行where再执行select最后再查排序输出

### 9.分组函数

#### 1.语法格式（多行处理函数）

​	count	计数

​	sum	求和

​	avg		平均值

​	max	最大值

​	min		最小值

> **注意：所有的分组函数都是对“某一组”数据进行操作的**
>
> **特点：分组函数会自动忽略null**

#### 2.例子：

​	**1.工资总和**

​	select sum(sal) from emp;

​	**2.找出最高工资**

​	select max(sal) from emp;

​	**3.找出最低工资**

​	select min(sal) from emp;

​	**4.找出平均工资**

​	select avg(sal) from emp;

​	**5.找出总人数**

​	select count(ename) from emp;

​	select count(*) from emp;

> **分组函数还有另外一个名字：多行处理函数。意思是输入多行输出一行**
>
> **除了多行处理函数，还有单行处理函数：输入一行处理一行**

​	**6.计算每个员工的年薪**

​	select ename,(sal+ifnull(comm,0)) * 12 as yearsal from emp;

> **重点：如果值中有null参与运算了，那么结果一定为null，所有数据库都是这样。**
>
> **可以使用ifnull空处理函数**
>
> **使用方法：ifnull（可能为null的字段，要当做什么数据处理）**
>
> **ifnull（可能为null的字段,0）意思是这个字段里面可能为null的值都当成0来处理**

​	**7.ifnull举例使用**

​	select ifnull(comm,0) as comm from emp;

> **字段名也会跟着变成ifnull格式，所以最好给他起个别名**

​	**8.找出工资高于平均工资的员工**

​	SELECT ename,sal FROM emp WHERE sal >(SELECT AVG(sal) FROM emp);

> **count（*）不是统计某个字段中数据的个数，而是统计总记录条数（和某个字段无关）**
>
> **count（comm）表示统计comm字段中不为NULL的数据总数量**

### 10.group by 和having

#### 1.语法格式

select 字段 from 表 group by 需要分组的字段 having 分组函数

 	group by：按照某个字段或者某些字段进行分组

​	having：对分组后的数据进行再次过滤

> **having是group by的搭档，不能单独使用**

**SQL语句的执行顺序：**

​	select				5 -----查询出来

​		..				字段名

​	from				1 -----查询什么表

​		..				表名

​	where				2 -----第一层过滤

​		..				条件，使用条件查询

​	group by			3 -----把字段进行分组

​		..				字段名

​	having				4 -----第二层过滤

​		..				条件，使用分组函数

​	order by				6 -----将查询完筛选完的数据进行排序

​		..				字段名、升序/降序

> **SQL语句当中有一个规则：分组函数不能直接使用在where子句后面？**
>
> **原因：因为where执行在group by之前，还未进行分组所以无法使用分组函数。**

> **注意：group by一般和分组函数一起使用，这也是为什么会被称为分组函数，并且任何一个分组函数（count sum avg max min）都是在group by语句执行结束之后才会执行。**
>
> **当一条sql语句没有group by的话，整张表的数据会自成一组。**

#### 2.例子：

​	**1.找出每个工作岗位的最高薪资**

​		SELECT job,MAX(sal) FROM emp GROUP BY job;

> SELECT ename，MAX(sal),job from emp group by job;
>
> **MYSQL当中：当一条SQL语句里面有group by时，select后面一定只能跟分组的字段和分组函数，而不能带其他字段，否则数据是对应不上的**
>
> **Oracle当中：会在执行后直接报错，oracle的语法规则比mysql语法严谨**

​	**2.每个工作岗位的平均薪资**

​	select job,avg(sal) from emp group by job;

​	**3.找出每个部门不同岗位的最高薪资**

​	select deptno,job,max(sal) from emp group by deptno,job;

> **联合分组在group by 后面加字段名即可，使用逗号隔开**

​	**4.找出每个部门的最高薪资，要求显示薪资大于2900的数据**

​	select deptno,max(sal) from emp where sal > 2900 group by deptno;

> **上面这种先使用where过滤后在分组的效率较高，建议使用**
>
> **还有一种解法：select deptno,max(sal) from emp group by having max(sal) > 2900;**
>
> **这种解法是先进行分组再过滤条件，这种效率较低，能不使用尽量不使用**

​	5.找出每个部门的平均薪资，要求显示薪资大于2000的数据

select deptno,avg(sal) from emp where sal > 2000 group by deptno;

> **上面这种解法是错误的，因为要得出每个部门的平均薪资是需要分组后进行分组函数的计算后才能得出的结果，如果使用where的话就会在分组计算前把2000给筛选掉，所以这里要使用having，分组后再进行过滤条件。而且where中不能使用分组函数，所以直接计算平均再筛会报错**

正确解法：select deptno,avg(sal) from emp group by deptno having avg(sal) > 2000;

## 11.DQL语句-总结

#### 1.完整语句 ----单表查询

> ​	*select*
>
> ​		..
>
> ​	from
>
> ​		..
>
> ​	where
>
> ​		..
>
> ​	group by
>
> ​		..
>
> ​	having
>
> ​		..
>
> ​	order by
>
> ​		*..*

### 12.distinct

#### 1.语法格式：

**distinct  去重，应用在select当中的字段**

select distinct 字段名 from 表名;

#### 2.例子

​	**1.关于查询结果集的去重**

​	select distinct job from emp;

> select ename,distinct job from emp;
>
> **以上SQL语句是错误的，distinct必须要在所有字段的最前面。**
>
> select distinct job,deptno from emp;
>
> **distinct会对select后的所有字段联合进行去重，而不是某一字段**

​	**2.统计岗位的数量**

​	select count(distinct deptno) from emp;

> **使用括号把distinct和岗位去重，之后再使用count计数。**

## 13.连接查询

**定义**：实际开发中，大部分的情况下都是不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。一般一个业务都会对应多张表。

**分类**：

**1.根据语法出现的年代来划分：**

​	SQL92：较老的语法（一些老的DBA可能还在使用这种语法，DBA：Database Admininstrator，数据库管理员）

​	SQL99：较新的语法

**2.根据表的连接方法来划分：**

​	**内连接：**

​		等值连接

​		非等值连接 between..and..（区间）

​		自连接

​	**外连接**

​		左外连接（左连接）

​		右外连接（右连接）

​	**全连接（这个不讲，很少用）**

**3.在表的连接查询方面有一种现象被称为：笛卡尔积现象（笛卡尔乘积现象）**

**现象**：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。

**不同表的连接查询原理**：两个表之间的连接查询是指A表的字段内一个数据拿来跟B表的字段内所有数据匹配，即1匹配多

​	**例子：找出每一个员工的部门名称，要求显示员工名和部门名**

​	select ename,dname from emp,dept;

​		14*4 = 56 rows in set (2.04 sec)，一共查出56条数据。

**如何避免笛卡尔积现象？或者说避免了笛卡尔积现象就能减少匹配次数了吗？**

​	**并不会，次数还是56次，只是显示的记录是有效记录，但匹配次数不变。**

​	select e.ename,d.dname from emp e,dept d where e.deptno = d.deptno; 

> 这样查询出来的数据就是为14条且部门一一对应，但匹配次数还是56次。

​	**关于表的别名：**

​		select e.ename d.dname from emp e,dept d;

​		1.执行效率高

​		2.可读性好

### 内连接-等值连接

**特点**：条件为等量关系。指的是A表与B表的连接条件为等量关系。他们之间是对等“=”的。

**语法顺序**

> ​	...
>
> ​	A
>
> ​	join
>
> ​	B
>
> ​	on
>
> ​	连接条件
>
> ​	where
>
> ​	...

​	例子：查询每个员工的部门名称，要求显示员工名和部门名

​	**SQL92写法：**

> select 
>
> ​	e.ename,d.dname 
>
> from 
>
> ​	emp e,dept d 
>
> where 
>
> ​	e.deptno = d.deptno;

​	**SQL99写法：**

> select 
>
> ​	e.ename,d.dname 
>
> from 
>
> ​	emp e 
>
> inner join	 (inner可以省略,带着inner的目的是可读性好一些,知道是使用内连接。)
>
>  	dept d
>
>  on 
>
> ​	e.deptno = d.deptno;

> **SQL99语法结构更清晰一些，表的连接条件和where条件分离了。**
>
> **92语句是使用where条件来连接表，但这样的话表连接后的数据筛选就没办法使用where条件了。所以99语法在这方面进行了优化。加入了join和on之后把where条件分离出来。**

### 内连接-非等值连接

**特点：连接条件中的关系是非等量关系。**

​	**例子：找出每个员工的工资等级，要求显示员工名、工资、工资等级**

​	SELECT e.ename,e.sal,s.grade FROM emp e JOIN salgrade s ON e.SAL BETWEEN s.LOSAL AND s.HISAL;

### 内连接-自连接

**特点：一张表看做两张表，自己连自己。**

​	**例子：找出每个员工的上级领导，要求显示员工名和对应的领导名**

​	select a.ename,b.ename from emp a join emp b on a.mgr = b.empno;

### 外连接

**内连接和外连接的区别：**

​	**内连接：**假设A表和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来。这就是内连接。AB之间没有主副之分，平等关系。

​	**外连接：**假设A表和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，另外一张是副表，主要查询主表中的数据，捎带着查询副表，如果副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。

> **左外连接：表示左边的表是主表**

> **右外连接：表示右边的表是主表**

	>**左连接有右连接的写法，右连接也有左连接的写法。**

​	**例子：**找出每个员工的上级领导

​	左外连接：

select a.ename,b.ename from emp a **left** join emp b on a.mgr = b.empno;	

​	右外连接：

select a.ename,b.ename from emp b **right** join emp a on a.mgr = b.empno;

> **左右连接的差别：左连接用left，右连接用right。**
>
> **左连接左表当主表，右表当副表**
>
> **右连接右表当主表，左表当副表**
>
> **外连接使用的比内连接的多。**
>
> 外连接最重要的特点就是主表的数据无条件的查询出来，不能因为null就连带着主表的数据一并不展示。

#### 三张表进行连接查询

​	例子：找出每一个员工的部门名称、工资等级、上级领导

> SELECT e.ename '员工',a.ename '领导',d.dname,s.grade 
> FROM emp e 
> JOIN dept d
> ON e.DEPTNO = d.DEPTNO
> JOIN salgrade s 
> ON e.SAL BETWEEN s.LOSAL AND s.HISAL
> LEFT JOIN emp a
> ON e.MGR = a.EMPNO;



### 14.子查询

**定义：select语句当中嵌套select语句，被嵌套的select语句就是子查询。**

**子查询出现在哪里：可以出现在select、from和where**

> ​	select
>
> ​	.. (select)
>
> ​	from
>
> ​	.. (select)
>
> ​	where
>
> ​	.. (select)

**1.where子句中使用子查询**

**例子：找出高于平均薪资的员工**

​	select * from emp where sal > (select avg(sal) from emp);

**2.from后面嵌套子查询**

​	**例子1：找出每个部门平均薪水的薪资等级**

> SELECT
> d.*,s.grade
> FROM
> (SELECT deptno,AVG(sal) avgsal FROM emp GROUP BY deptno) d
> JOIN
> salgrade s
> ON
> d.avgsal BETWEEN s.LOSAL AND s.HISAL;
>
> 这种from后面嵌套子查询会非常常用。
>
> 嵌套的子查询会把他当做一个临时表使用

**例子2：找出每个部门平均的薪水等级（跟以上例子无关）**

> SELECT 
> e.DEPTNO,AVG(s.grade) 
> FROM emp e 
> JOIN salgrade s 
> ON e.SAL 
> BETWEEN s.LOSAL 
> AND s.HISAL 
> GROUP BY e.DEPTNO;

**3.select后面嵌套子查询**

​	**例子：找出每个员工所在的部门名称，要求显示员工和部门名**

> SELECT e.ename,
> (SELECT d.dname FROM dept d WHERE d.deptno = e.deptno) ename 
> FROM emp e;

### 15.union

**定义：可以将查询结果集相加，就是把查询语句的结果结合在一起。**

​	**例子：找出工作岗位是SALESMAN和MANAGER的员工**

​	**第一种解法：**

> select ename,job from emp where job = 'SALESMAN' or job = 'MANAGER'

​	**第二种解法：**

> select ename,job from emp where job in ('SALESMAN','MANAGER')

​	**第三种解法：**

> ​	select ename from emp where job = 'SALESMAN'
>
> ​	union
>
> ​	select ename from emp where job = 'MANAGER'

### 16.limit(分页查询；重点中的重点！)

**定义：limit是MYSQL特有的，其他数据库没有，不通用。**

**作用：limit是取结果集中的部分数据。**

> Oracle中有一个相同的机制，叫做rownum
>
> **limit是SQL语句中最后执行的一个环节**

语法格式：limit startIndex，length

​	startIndex表示起始位置

​	length表示取几个

​	**例子：取出工资前5名的员工（降序取前5个）**

> ​	SELECT
> ​	ename,sal
> ​	FROM
> ​	emp
> ​	ORDER BY
> ​	sal DESC
> ​	LIMIT 0,5;

​	**例子：取出工资第4名到第9名的员工**

> ​	SELECT
> ​	ename,sal
> ​	FROM
> ​	emp
> ​	ORDER BY
> ​	sal DESC
> ​	LIMIT 3,6;

#### 17.TimeStampDiff（时间间隔查询）

**语法格式：**

​	TimeStampDiff（间隔类型，要查询的字段名，now（））

**间隔类型：**

​	SECOND		秒

​	MINUTE		分钟

​	HOUR		小时

​	DAY			天

​	WEEK		星期

​	MONTH		月

​	QUARTER	季度

​	YEAR		年

## MYSQL-34道练习题

#### 1.取得每个部门最高薪水的人员名称

第一步：查询每个部门的最高薪资

第二步：把第一步当临时表，把ename与临时表进行条件匹配即可

> SELECT a.ENAME,b.*
> FROM emp a 
> JOIN (SELECT deptno,MAX(sal) maxsal FROM emp GROUP BY deptno) b
> ON
> a.SAL = b.maxsal AND a.DEPTNO = b.deptno;

#### 2.那些人的薪水在部门的平均薪水之上

> SELECT a.ename,a.sal,b.avgsal
> FROM
> emp a
> JOIN
> (SELECT deptno,AVG(sal) AS avgsal FROM emp GROUP BY deptno) b
> ON
> b.deptno = a.deptno AND a.sal > b.avgsal
> ORDER BY  
> sal DESC;

#### 3.取得部门中（所有人）平均的薪水等级

**所有人的平均薪资的等级**

> SELECT
> b.*,s.grade
> FROM
> salgrade s
> LEFT JOIN
> (SELECT ename,AVG(sal) AS avgsal FROM emp GROUP BY ename) b
> ON
> b.avgsal BETWEEN s.losal AND s.hisal;

**部门的平均的薪水等级**

> SELECT 
> e.DEPTNO,AVG(s.grade) 
> FROM emp e 
> JOIN salgrade s 
> ON e.SAL 
> BETWEEN s.LOSAL 
> AND s.HISAL 
> GROUP BY e.DEPTNO;

#### 4.不准用分组函数MAX，取得最高薪水（给出2种解决方案） 

第一种：把工资降序，然后limit展示第一条数据，就是最高工资了。

select ename,sal from emp order by sal desc limit 0,1;

第二种：使用自连接，创建一条sal临时表，salA表小于salB表，由于A表最高工资不会小于B表里的任何工资，所以不会展示出来，这种情况下在使用is not把最高工资拿出来即可。

select distinct a.sal from emp a join emp b on a.sal<b.sal ----子查询

select sal from emp where sal not in (子查询表)



#### 5.取得平均薪水最高的部门的部门编号（至少给2种解决方案）

**第一种：使用limit排序，把工资降序然后limit展示第一条数据即可**

**步骤：先找出各个部门的平均薪水，然后排序再limit**

> SELECT 
> deptno,AVG(sal) avgsal 
> FROM 
> emp 
> GROUP BY 
> deptno 
> ORDER BY 
> avgsal 
> DESC 
> LIMIT 0,1;

**第二种：使用MAX，把部门平均薪水表当成临时表后求最大即可**

**步骤：先找出各个部门的平均薪水，然后当临时表使用MAX分组函数求最大值**

> SELECT 
> t.deptno,MAX(t.avgsal) 
> FROM 
> (SELECT deptno,AVG(sal) avgsal FROM emp GROUP BY deptno) t;



#### 6.取平均薪水最高的部门的部门名称

**解法：使用limit排序，把平均工资得出来后当成临时表，用外连接把临时表跟部门表连接，然后根据临时表的平均部门工资进行倒序，然后limit筛出。**

> SELECT
> d.dname,AVG(sal) avgsal
> FROM
> emp e
> JOIN
> dept d
> ON
> e.deptno = d.deptno
> GROUP BY
> e.deptno
> ORDER BY
> avgsal DESC
> LIMIT
> 0,1;

#### 7.求平均薪水的等级最低的部门的部门名称

**解法：使用limit排序，把平均薪水的等级按照部门分组，然后在根据等级来升序，最后用limit来过滤。**

> SELECT
> e.dname,e.avgsal,s.grade
> FROM
> (SELECT d.dname,a.deptno,AVG(a.sal) avgsal FROM emp a JOIN dept d ON a.deptno = d.deptno GROUP BY deptno) e
> LEFT JOIN
> salgrade s
> ON
> avgsal BETWEEN s.losal AND s.hisal
> GROUP BY
> e.DEPTNO
> ORDER BY
> s.grade ASC
> LIMIT
> 0,1;

#### 8.取的比普通员工（员工代码没有在mgr字段上出现的）的最高薪水还要高的领导人姓名

**解法：先使用去重把领导人都筛出来当临时表，然后用emp表对比这个临时表，把普通员工的最高薪水得出来，然后用emp的薪资对比临时表得出结果**

> SELECT
> ename
> FROM
> emp
> WHERE
> sal > (SELECT
> MAX(sal)
> FROM
> emp
> WHERE
> empno NOT IN (SELECT DISTINCT mgr FROM emp WHERE mgr IS NOT NULL))

#### 9.取得薪水最高的前五名员工

**解法：使用order by把薪资降序排列，后用limit过滤**

> SELECT
> ename,sal
> FROM
> emp
> ORDER BY
> sal DESC
> LIMIT
> 0,5

#### 10.取得薪水最高的第六到第十名员工

**解法：使用order by把薪资降序排列，后用limit过滤**

> SELECT
> ename,sal
> FROM
> emp
> ORDER BY
> sal DESC
> LIMIT
> 5,5

#### 11.取得最后入职的5名员工

**解法：使用order by把入职日期降序排列，后用limit过滤**

> SELECT
> ename,hiredate
> FROM
> emp
> ORDER BY
> hiredate DESC
> LIMIT
> 0,5

#### 12.取得每个薪水等级有多少名员工

**解法：使用分组函数count计数，然后给grade分组即可。**

> SELECT
> s.grade AS '薪资等级',COUNT(s.grade) AS '共计员工数'
> FROM
> emp e
> JOIN
> salgrade s
> ON
> e.sal BETWEEN s.losal AND s.hisal
> GROUP BY
> s.grade

#### 13.有3个表s（学生表），c（课程表），sc（学生选课表）

s（sno，sname）代表（学号，姓名）

c（cno，cname，cteacher）代表（课号，课名，教师）

sc（sno，cno，scgrade）代表（学号，课号，成绩）

问题1：找出没选过“黎明”老师的所有学生姓名

问题2：列出2门以上（含2门）步即可学生姓名及平均成绩

问题3：即学过1号课程又学过2号课程的所有学生的姓名

#### 14.列出所有员工及领导的姓名

**解法：使用左外连接查询，可以把null也展示出来**

SELECT
a.ename,b.ename
FROM
emp a
LEFT JOIN
emp b
ON
a.mgr = b.empno;

#### 15.列出受雇日期早于其直接上级的所有员工的编号、姓名、部门名称

**解法：先用自连接把员工和直接上级筛选出来，然后再外连接dept表，把部门名称取出来，最后用where条件把员工入职日期早于领导入职日期过滤出来**

> SELECT
>
> a.empno,a.ename,d.dname,a.hiredate,b.hiredate
> FROM
> emp a
> LEFT JOIN
> emp b
> ON
> a.mgr = b.empno
> LEFT JOIN
> dept d
> ON
> a.deptno = d.deptno
> WHERE
> a.hiredate < b.hiredate;

#### 16.列出部门名称和这些部门的员工信息，同时列出哪些没有员工的部门

**解法：列出所有的员工信息和部门名称即可**

> SELECT
> a.dname,e.*
> FROM
> dept a
> JOIN
> emp e
> ON
> a.deptno = e.deptno;

#### 17.列出至少有5个员工的所有部门

**解法：group by对deptno分组，然后count计数即可，我使用了外连接是因为我以为需要取得部门名称，实际不需要，下面列出2种写法中第一张是取得部门名称，而第二种没有。**

**第一种：取得员工数量大于等于5的部门名称**

> SELECT
> d.dname
> FROM
> dept d
> JOIN
> emp e
> ON
> d.deptno = e.deptno
> GROUP BY
> e.deptno
> HAVING
> COUNT(e.deptno) >= 5;

#### **第二种：取得员工数量大于等于5的部门编号**

> SELECT
> deptno
> FROM
> emp
> GROUP BY
> deptno
> HAVING
> COUNT(deptno) >= 5;

#### 18.列出薪资比“SMITH”多的所有员工信息 

**解法：子查询得出SMITH的薪资，后再用SAL去比较SMITH的薪资，得出结果**

> SELECT
> *
> FROM
> emp
> WHERE
> sal > (SELECT sal FROM emp WHERE ename = 'SMITH');

#### 19.列出所有办事员（CLERK）的姓名及其部门名称和部门的人数

**解法：**

**1.先找出所有办事员为'CLERK'的姓名、部门名称**

**2.然后找出部门的人数**

**3.把以上两个SQL语句都当成临时表，拼接即可。**

> SELECT
> t1.*,t2.countdeptno
> FROM
> (SELECT e.ename,d.dname,e.deptno FROM emp e JOIN dept d ON e.deptno = d.deptno WHERE job = 'CLERK') t1
> JOIN
> (SELECT deptno,COUNT() countdeptno FROM emp GROUP BY deptno) t2 ON
> t1.deptno = t2.deptno

#### 20.列出最低薪资大于1500的各种工作及从事此工作的全部雇员人数

**解法：用分组函数把job进行分组，然后用having过滤最低薪资为1500以下的，最后使用count计数即可**

> SELECT
> job,COUNT(job)
> FROM
> emp
> GROUP BY
> job
> HAVING
> MIN(sal) > 1500;

#### 21.列出在部门‘SALES’<销售部>工作的员工的姓名，假定不知道销售部的部门编号

**解法：子查询找出部门名为'SALES'的部门编号，再查询该部门下的员工姓名**

> SELECT
> ename
> FROM
> emp
> WHERE
> deptno = (SELECT deptno FROM dept WHERE dname = 'SALES')

#### 22.列出薪资高于公司平均薪资的所有员工，所在部门，上级领导和雇员的工资等级 

**解法：先找出平均薪资，然后通过表链接找到所在部门和上级领导和工资等级，展示所有条件再加上子查询平均薪资即可**

> SELECT
> e.ename,d.dname,a.ename,s.grade
> FROM
> emp e
> JOIN
> dept d
> ON
> e.deptno = d.deptno
> LEFT JOIN
> emp a
> ON
> e.mgr = a.empno
> JOIN
> salgrade s
> ON
> e.sal BETWEEN s.losal AND s.hisal
> WHERE
> e.sal > (SELECT AVG(sal) FROM emp);

#### 23.列出与“SCOTT”从事相同工作的所有员工及部门名称

**解法：先找出“SCOTT”的工作岗位，然后关联dept表找出部门名称**

> SELECT
> e.ename,e.job,d.dname
> FROM
> emp e
> JOIN
> dept d
> ON
> d.deptno = e.deptno
> WHERE
> e.job = (SELECT job FROM emp WHERE ename = 'SCOTT')
> AND
> e.ename != 'SCOTT'

#### 24.列出薪资等于部门30中员工的薪资的其他员工的姓名和薪资

没理解题意，不写。

#### 25.列出薪资高于在部门30工作的所有员工的薪资的员工姓名和薪资、部门名称

解法：先找出部门30的员工中最高薪资，然后在表链接找出部门名称

> SELECT
> e.ename,e.sal,d.dname
> FROM
> emp e
> JOIN
> dept d
> ON
> e.deptno = d.deptno
> WHERE
> e.sal > (SELECT MAX(sal) FROM emp WHERE deptno = 30);

#### 26.列出在每个部门工作的员工数量，平均工资和平均服务期限

解法：外连接emp和dept表，然后根据deptno分组 ，用分组函数求得员工数量、平均工资和平均服务期限。

> SELECT
> d.deptno,COUNT(e.ename),IFNULL(AVG(e.sal),0),IFNULL(AVG(TIMESTAMPDIFF(YEAR,hiredate,NOW())),0) '时间间隔'
> FROM
> emp e
> RIGHT JOIN
> dept d
> ON
> e.deptno = d.deptno
> GROUP BY
> d.deptno;

#### 27.列出所有员工的姓名、部门名称和工资

**解法：外连接emp表和dept表查询即可**

> SELECT
> e.ename,d.dname,e.sal
> FROM
> emp e
> JOIN
> dept d
> ON
> e.deptno = d.deptno

#### 28.列出所有部门的详细信息和人数

**解法：外连接emp和dept表，右连接dept表，展示dept的所有数据，然后用deptno进行分组，最后用count计算人数即可**

> SELECT
> d.*,COUNT(e.deptno) '人数'
> FROM
> emp e
> RIGHT JOIN
> dept d
> ON
> e.deptno = d.deptno
> GROUP BY
> d.deptno

#### 29.列出各种工作的最低工资及从事此工作的雇员

**解法：先找出每个工种的最低工资，然后用外连接emp表和最低工资表t，条件对比即可**

> SELECT 
> t.*,e.ename
> FROM
> emp e
> JOIN
> (SELECT job,MIN(sal) AS minsal FROM emp GROUP BY job) t
> ON
> e.job = t.job AND e.sal = t.minsal;

#### 30.列出各个部门的MANGER（领导）的最低薪资

**解法：先找出job为‘MANAGER’的员工，然后把部门进行分组，最后用分组函数把最低薪资求出即可**

> SELECT
> deptno,ename,MIN(sal),job
> FROM
> emp
> WHERE
> job = 'MANAGER'
> GROUP BY
> deptno

#### 31.列出所有员工的年工资，按年薪从低到高排序

**解法：找出年工资再排序**

> SELECT
> ename,(sal+IFNULL(comm,0))*12 AS salcomm
> FROM
> emp
> ORDER BY
> salcomm ASC;

#### 32.求出员工领导的薪水超过3000的员工名称和领导

**解法：自连接把员工和领导信息找出来，再通过where条件筛选即可**

> SELECT
> a.ename '员工',b.ename '领导'
> FROM
> emp a
> JOIN
> emp b
> ON
> a.mgr = b.empno
> WHERE
> b.sal > 3000;

#### 33.求出部门名称中带S字符的部门员工的工资合计、部门人数

**解法：右外连接emp和dept，然后where条件筛选部门名称为S的，用group by把dept表进行分组，然后用分组函数得出工资合计和统计部门人数**

> SELECT
> d.dname,d.deptno,d.loc,SUM(e.sal),COUNT(e.deptno)
> FROM
> emp e
> RIGHT JOIN
> dept d
> ON
> e.deptno = d.deptno
> WHERE
> d.dname LIKE '%S%'
> GROUP BY
> d.dname,d.deptno,d.loc

#### 34.给任职时间超过30年的员工加薪10%

用的update，暂时不写。

## 员工部门表综合查询60题

> 注：题目&答案均来自https://www.jianshu.com/p/c591f4769057
>
> 

```csharp
（1） 查询20部门的所有员工信息。
解：
SELECT ename,deptno FROM emp WHERE deptno = 20;
```

```csharp
（2） 查询所有工种为CLERK的员工的员工号、员工名和部门号。
解：
SELECT empno,ename,deptno,job FROM emp WHERE job = 'CLERK';
```

```csharp
（3） 查询奖金（COMM）高于工资（SAL）的员工信息。
解：
SELECT * FROM emp WHERE comm > sal;
```

```csharp
（4） 查询奖金高于工资的20%的员工信息。
解：
SELECT * FROM emp WHERE comm > (sal * 0.2);
```

```csharp
（5） 查询10号部门中工种为MANAGER和20部门中工种为CLERK的员工的信息。
解：
SELECT * FROM emp WHERE (deptno = 10 AND job = 'manager') OR (deptno = 20 AND job = 'CLERK') ORDER BY deptno DESC;
```

```csharp
（6）查询所有工种不是MANAGER和CLERK，--且工资大于或等于2000的员工的详细信息。
解：
SELECT * FROM emp WHERE (job != 'manager' OR 'clerk') AND sal >= 2000;
```

```csharp
（7） 查询有奖金的员工的不同工种。
解：
select distinct job from emp where comm is not null
```

```csharp
（8） 查询所有员工工资与奖金的和。
解：
SELECT ename,(sal+IFNULL(comm,0)) FROM emp;
```

```csharp
（9） 查询没有奖金或奖金低于100的员工信息。
解：
SELECT * FROM emp WHERE comm IS NULL OR comm < 100;
```

```csharp
（10） 查询各月倒数第3天(倒数第2天)入职的员工信息。
解：
SELECT * FROM emp WHERE HIREDATE = LAST_DAY(HIREDATE)-2;
```

```csharp
（11） 查询工龄大于或等于25年的员工信息。
解：
SELECT
*
FROM
emp
WHERE
TIMESTAMPDIFF(YEAR,hiredate,NOW()) >= 25;
```

```csharp
（12） 查询员工信息，要求以首字母大写的方式显示所有员工的姓名。
    解：
    
```

```mysql
（13） 查询员工名正好为6个字符的员工的信息。
    解：
    SELECT * FROM emp WHERE CHAR_LENGTH(ENAME) = 6;
```

```mysql
（14） 查询员工名字中不包含字母“Ｓ”的员工。
解：
SELECT ename FROM emp WHERE ename NOT LIKE '%Ｓ%'
```

```csharp
（15） 查询员工姓名的第二字母为“M”的员工信息。
解：
SELECT
*
FROM
emp
WHERE
ename LIKE '_M%'
```

```mysql
（16） 查询所有员工姓名的前三个字符。
解：   
SELECT ENAME,SUBSTRING(ENAME,1,3) 名称前三位 FROM emp;
```

```mysql
（17） 查询所有员工的姓名，如果包含字母“S”，则用“s”替换。
解：
SELECT ename,REPLACE(ENAME,'S','s') FROM emp;
```

```csharp
（18） 查询员工的姓名和入职日期，并按入职日期从先到后进行排序。
解：
SELECT
ename,hiredate
FROM
emp
ORDER BY
hiredate ASC;
```

```csharp
（19） 显示所有员工的姓名、工种、工资和奖金，按工种降序排序，
解：
SELECT
ename,job,sal,comm
FROM
emp
ORDER BY
job DESC;
```

```mysql
（20） 显示所有员工的姓名、入职的年份和月份
解：
SELECT ENAME 员工姓名, YEAR(HIREDATE) 入职年份, MONTH(HIREDATE) 入职月份 FROM emp;
```

```mysql
（21） 查询在2月份入职的所有员工信息。
解：
SELECT * FROM emp WHERE MONTH(HIREDATE) = 2;
```

```csharp
（22） 查询所有员工入职以来的工作期限，用“XX年XX月XX日”的形式表示。
解：
SELECT ENAME 员工名称, DATE_FORMAT(HIREDATE,'%Y年%m月%d天') 入职日期 FROM emp;
```

```csharp
（23.1） 查询至少有一个员工的部门信息。
解：
SELECT
d.*,COUNT(e.ename) AS countename
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
d.deptno
HAVING
countename > 1;
```

```csharp
（23.2） 查询至少有两个员工的部门信息。
解：
SELECT
d.*,COUNT(e.ename) AS countename
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
d.deptno
HAVING
countename > 2;
```

```csharp
（24） 查询工资比SMITH员工工资高的所有员工信息。
解：
SELECT
*
FROM
emp
WHERE
sal > (SELECT sal FROM emp WHERE ename = 'SMITH');
```

```csharp
（25） 查询所有员工的姓名及其直接上级的姓名。
解：
SELECT
a.ename AS '员工姓名',b.ename AS '领导姓名'
FROM
emp a
JOIN
emp b
ON
a.mgr = b.empno;
```

```csharp
（26） 查询入职日期早于其直接上级领导的所有员工信息。
解：
SELECT
a.ename,a.hiredate '员工入职日期',b.hiredate '领导入职日期'
FROM
emp a
JOIN
emp b
ON
a.mgr = b.empno
WHERE
a.hiredate < b.hiredate;
```

```csharp
（27） 查询所有部门及其员工信息，包括那些没有员工的部门。
解：
SELECT
d.dname,e.ename
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno;
```

```csharp
（28） 查询所有员工及其部门信息，包括那些还不属于任何部门的员工。
解：
SELECT
d.dname,e.ename
FROM
emp e
LEFT JOIN
dept d
ON
e.deptno = d.deptno;
```

```csharp
（29） 查询所有工种为CLERK的员工的姓名及其部门名称。
解：
SELECT
e.job,e.ename,d.dname
FROM
emp e
LEFT JOIN
dept d
ON
e.deptno = d.deptno
WHERE
e.job = 'CLERK';
```

```csharp
（30） 查询工种中最低工资大于2500的。
解：
SELECT
job
FROM
emp
GROUP BY
job
HAVING
MIN(sal) > 2500;
```

```csharp
（31） 查询平均工资低于2000的部门并展示该部门的员工信息。
解：
SELECT *
FROM dept LEFT OUTER JOIN emp ON dept.deptno=emp.deptno
WHERE dept.deptno IN (
SELECT deptno FROM emp
GROUP BY deptno
HAVING AVG(sal)<2000)
```

```csharp
（32） 查询在SALES部门工作的员工的姓名信息。
解：
SELECT
d.dname,e.ename
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
WHERE
d.dname = 'SALES';
```

```csharp
（33） 查询工资高于公司平均工资的所有员工信息。
解：
SELECT
*
FROM
emp
WHERE
sal > (SELECT AVG(sal) FROM emp);
```

```csharp
（34） 查询出与SMITH员工从事相同工作的所有员工信息。
解：
SELECT
*
FROM
emp
WHERE
job = (SELECT job FROM emp WHERE ename = 'SMITH')
```

```csharp
（35） 列出工资等于30部门中某个员工的工资的所有员工的姓名和工资。
解：
SELECT
ename,sal
FROM
emp
WHERE
sal IN (SELECT sal FROM emp WHERE deptno = 30)
AND
deptno != 30;
```

```csharp
（36） 查询工资高于30部门工作的所有员工的工资的员工姓名和工资。
解：
SELECT
ename,sal
FROM
emp
WHERE
sal > (SELECT MAX(sal) FROM emp WHERE deptno = 30)
AND
deptno != 30;
```

```csharp
（37） 查询每个部门中的员工数量、平均工资和平均工作年限。
解：
SELECT
e.deptno '部门编号',COUNT(e.ename) '部门人数',AVG(e.sal) '平均工资',AVG(TIMESTAMPDIFF(YEAR,e.hiredate,NOW())) AS '平均年限'
FROM
emp e
JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
e.deptno;
```

```csharp
（38） 查询从事同一种工作但不属于同一部门的员工信息。
```

```csharp
（39） 查询各个部门的详细信息以及部门人数、部门平均工资。
解：
SELECT
d.*,COUNT(e.ename),IFNULL((AVG(e.sal)),0)
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
e.deptno;
```

```csharp
（40） 查询各种工作的最低工资。
解：
SELECT
job,MIN(sal)
FROM
emp
GROUP BY
job;
```

```csharp
（41） 查询各个部门中不同工种的最高工资。
解：
SELECT
d.dname,e.job,MAX(e.sal)
FROM
emp e
JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
d.dname,e.job;
```

```csharp
（42） 查询10号部门员工及其领导的信息。
解：
SELECT
a.ename,b.ename
FROM
emp a
LEFT JOIN
emp b
ON
a.mgr = b.empno
WHERE
a.deptno = 10;
```

```csharp
（43） 查询各个部门的人数及平均工资。
解：
SELECT
d.dname,COUNT(e.ename),IFNULL(AVG(e.sal),0) '平均工资'
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
e.deptno;
```

```csharp
（44） 查询工资为某个部门平均工资的员工的信息。
解：
SELECT
*
FROM
emp
WHERE
sal IN (SELECT AVG(sal) FROM emp GROUP BY deptno)
```

```csharp
（45） 查询工资高于本部门平均工资的员工的信息。
解：
SELECT
*
FROM
emp a
JOIN
(SELECT AVG(sal) avgsal,deptno FROM emp GROUP BY deptno) b
WHERE
a.sal >  b.avgsal AND a.deptno = b.deptno;
```

```csharp
（46） 查询工资高于本部门平均工资的员工的信息及其部门的平均工资。
解：
SELECT
a.ename,b.avgsal
FROM
emp a
JOIN
(SELECT AVG(sal) avgsal,deptno FROM emp GROUP BY deptno) b
WHERE
a.sal >  b.avgsal AND a.deptno = b.deptno;
```

```csharp
（47） 查询工资高于20号部门某个员工工资的员工的信息。
解：
SELECT
*
FROM
emp
WHERE
sal > ANY(SELECT sal FROM emp WHERE deptno = 20);
```

```csharp
（48）统计各个工种的员工人数与平均工资。
解：
SELECT
COUNT(ename),AVG(sal)
FROM
emp
GROUP BY
job;
```

```csharp
（49） 统计每个部门中各工种的人数与平均工资。
解：
SELECT
d.dname,e.job,COUNT(e.ename) countename,AVG(e.sal)
FROM
emp e
RIGHT JOIN
dept d
ON
e.deptno = d.deptno
GROUP BY
d.dname,e.job
ORDER BY
countename ASC;
```

```csharp
（50） 查询其他部门中工资、奖金与30号部门某员工工资、奖金都相同的员工的信息。没有查询结果
```

```csharp
（51） 查询部门人数大于5的部门的员工信息。
解：
SELECT
*
FROM
emp
WHERE
deptno = 
(SELECT
deptno
FROM
emp
GROUP BY
deptno
HAVING
COUNT(ename) >5)
```

```csharp
（52） 查询所有员工工资都大于1000的部门的信息。
解：
SELECT
*
FROM
dept
WHERE
deptno IN (SELECT deptno FROM emp GROUP BY deptno HAVING MIN(sal)> 1000)
```

```csharp
（53） 查询所有员工工资都大于1000的部门的信息及其员工信息。
解：
SELECT *
FROM dept d LEFT OUTER JOIN emp e ON d.deptno=e.deptno
WHERE e.deptno IN (
SELECT deptno FROM emp e1
GROUP BY deptno
HAVING MIN(sal)>1000
)
```

```csharp
（54） 查询所有员工工资都在900～3000之间的部门的信息。
```

```csharp
（55） 查询有工资在900～3000之间的员工所在部门的员工信息。
```

```csharp
（56） 查询每个员工的领导所在部门的信息。
```

```csharp
（57） 查询人数最多的部门信息。
```

```csharp
（58） 查询30号部门中工资排序前3名的员工信息。
```

```csharp
（59） 查询所有员工中工资排序在5到10名之间的员工信息。
```

```csharp
（60） 查询指定年份之间入职的员工信息。(1980-1985)
```

>>>>>>> 1b9e5a0ee0ed381fdca8d26c9fd41071bfffb8b8
